import { PDFDocument, rgb, StandardFonts, PageSizes } from 'pdf-lib'
import html2canvas from 'html2canvas'
import { PropulsionMetrics } from './metric-extraction'
import { ClassificationResult, getClassificationDisplay } from './burn-classifier'
import { ParsedData } from './file-processors'

export interface ReportData {
  fileName: string
  parsedData: ParsedData
  metrics: PropulsionMetrics | null
  classification?: ClassificationResult | null
  timestamp: Date
}

export interface ReportOptions {
  includeMetrics: boolean
  includeClassification: boolean
  includeDataPreview: boolean
  includeCharts: boolean
  chartElements?: HTMLElement[]
}

export class PDFReportGenerator {
  private pdfDoc: PDFDocument | null = null
  private font: any = null
  private boldFont: any = null

  async initialize(): Promise<void> {
    this.pdfDoc = await PDFDocument.create()
    this.font = await this.pdfDoc.embedFont(StandardFonts.Helvetica)
    this.boldFont = await this.pdfDoc.embedFont(StandardFonts.HelveticaBold)
  }

  async generateReport(data: ReportData, options: ReportOptions): Promise<Uint8Array> {
    if (!this.pdfDoc || !this.font || !this.boldFont) {
      await this.initialize()
    }

    const { fileName, parsedData, metrics, classification, timestamp } = data
    
    // Add title page
    this.addTitlePage(fileName, timestamp)
    
    // Add metrics summary
    if (options.includeMetrics && metrics) {
      this.addMetricsPage(metrics, fileName)
    }
    
    // Add AI classification
    if (options.includeClassification && classification) {
      this.addClassificationPage(classification, fileName)
    }
    
    // Add data preview
    if (options.includeDataPreview) {
      this.addDataPreviewPage(parsedData)
    }
    
    // Add charts
    if (options.includeCharts && options.chartElements) {
      await this.addChartsPages(options.chartElements)
    }

    return this.pdfDoc!.save()
  }

  private addTitlePage(fileName: string, timestamp: Date): void {
    const page = this.pdfDoc!.addPage(PageSizes.A4)
    const { width, height } = page.getSize()
    
    const titleY = height - 100
    const subtitleY = titleY - 50
    const fileY = subtitleY - 80
    const dateY = fileY - 30
    const summaryY = dateY - 100

    // Title
    page.drawText('Propulsion Test Analysis Report', {
      x: 50,
      y: titleY,
      size: 24,
      font: this.boldFont,
      color: rgb(0.2, 0.2, 0.6)
    })

    // Subtitle
    page.drawText('AI Analytics Tool - Generated Report', {
      x: 50,
      y: subtitleY,
      size: 16,
      font: this.font,
      color: rgb(0.4, 0.4, 0.4)
    })

    // File info
    page.drawText(`Test File: ${fileName}`, {
      x: 50,
      y: fileY,
      size: 14,
      font: this.boldFont,
      color: rgb(0, 0, 0)
    })

    page.drawText(`Generated: ${timestamp.toLocaleString()}`, {
      x: 50,
      y: dateY,
      size: 12,
      font: this.font,
      color: rgb(0.3, 0.3, 0.3)
    })

    // Summary box
    const summaryText = `This report contains automated analysis of propulsion test data including:
• Extracted performance metrics (peak thrust, rise time, burn duration)
• AI-powered anomaly detection and classification
• Data quality assessment and visualization
• Statistical analysis and comparison tools`

    page.drawText(summaryText, {
      x: 50,
      y: summaryY,
      size: 12,
      font: this.font,
      color: rgb(0, 0, 0),
      lineHeight: 18
    })

    // Footer
    page.drawText('Generated by AI Analytics Tool - General Galactic TestLab', {
      x: 50,
      y: 50,
      size: 10,
      font: this.font,
      color: rgb(0.5, 0.5, 0.5)
    })
  }

  private addMetricsPage(metrics: PropulsionMetrics, fileName: string): void {
    const page = this.pdfDoc!.addPage(PageSizes.A4)
    const { width, height } = page.getSize()
    
    let currentY = height - 80

    // Page title
    page.drawText('Performance Metrics Analysis', {
      x: 50,
      y: currentY,
      size: 20,
      font: this.boldFont,
      color: rgb(0.2, 0.2, 0.6)
    })
    
    currentY -= 30

    page.drawText(`File: ${fileName}`, {
      x: 50,
      y: currentY,
      size: 12,
      font: this.font,
      color: rgb(0.4, 0.4, 0.4)
    })

    currentY -= 50

    // Metrics grid
    const metricsData = [
      { label: 'Peak Thrust', value: metrics.peakThrust, unit: 'N' },
      { label: 'Rise Time', value: metrics.riseTime, unit: 's' },
      { label: 'Burn Duration', value: metrics.burnDuration, unit: 's' },
      { label: 'Total Impulse', value: metrics.areaUnderCurve, unit: 'N·s' },
      { label: 'Peak Thrust Time', value: metrics.peakThrustTime, unit: 's' },
      { label: 'Burn Start Time', value: metrics.burnStartTime, unit: 's' },
      { label: 'Burn End Time', value: metrics.burnEndTime, unit: 's' }
    ]

    metricsData.forEach((metric, index) => {
      if (index % 2 === 0 && index > 0) {
        currentY -= 30
      }
      
      const x = index % 2 === 0 ? 50 : 300
      const valueText = metric.value !== null ? `${metric.value.toFixed(3)} ${metric.unit}` : 'N/A'
      
      page.drawText(`${metric.label}:`, {
        x,
        y: currentY,
        size: 12,
        font: this.boldFont,
        color: rgb(0, 0, 0)
      })
      
      page.drawText(valueText, {
        x: x + 120,
        y: currentY,
        size: 12,
        font: this.font,
        color: rgb(0.2, 0.2, 0.2)
      })
      
      if (index % 2 !== 0 || index === metricsData.length - 1) {
        currentY -= 25
      }
    })

    // Performance calculations
    if (metrics.peakThrust && metrics.burnDuration && metrics.areaUnderCurve) {
      currentY -= 30

      page.drawText('Derived Performance Metrics', {
        x: 50,
        y: currentY,
        size: 16,
        font: this.boldFont,
        color: rgb(0.2, 0.2, 0.6)
      })

      currentY -= 30

      const avgThrust = metrics.areaUnderCurve / metrics.burnDuration
      const specificImpulse = metrics.areaUnderCurve / (metrics.peakThrust * metrics.burnDuration)
      const thrustToWeight = metrics.peakThrust / 9.81

      const derivedMetrics = [
        { label: 'Average Thrust', value: `${avgThrust.toFixed(1)} N` },
        { label: 'Specific Impulse', value: `${specificImpulse.toFixed(2)} s` },
        { label: 'Thrust-to-Weight', value: `${thrustToWeight.toFixed(1)} kg` }
      ]

      derivedMetrics.forEach(metric => {
        page.drawText(`${metric.label}:`, {
          x: 50,
          y: currentY,
          size: 12,
          font: this.boldFont,
          color: rgb(0, 0, 0)
        })
        
        page.drawText(metric.value, {
          x: 200,
          y: currentY,
          size: 12,
          font: this.font,
          color: rgb(0.2, 0.2, 0.2)
        })
        
        currentY -= 25
      })
    }

    // Warnings
    if (metrics.warnings.length > 0) {
      currentY -= 30

      page.drawText('Analysis Warnings', {
        x: 50,
        y: currentY,
        size: 16,
        font: this.boldFont,
        color: rgb(0.8, 0.4, 0)
      })

      currentY -= 30

      metrics.warnings.forEach(warning => {
        const lines = this.wrapText(warning, this.font, 12, width - 100)
        lines.forEach(line => {
          page.drawText(`• ${line}`, {
            x: 50,
            y: currentY,
            size: 10,
            font: this.font,
            color: rgb(0.6, 0.3, 0)
          })
          currentY -= 15
        })
        currentY -= 5
      })
    }
  }

  private addClassificationPage(classification: ClassificationResult, fileName: string): void {
    const page = this.pdfDoc!.addPage(PageSizes.A4)
    const { width, height } = page.getSize()
    const display = getClassificationDisplay(classification)
    
    let currentY = height - 80

    // Page title
    page.drawText('AI Classification Analysis', {
      x: 50,
      y: currentY,
      size: 20,
      font: this.boldFont,
      color: rgb(0.2, 0.2, 0.6)
    })
    
    currentY -= 30

    page.drawText(`File: ${fileName}`, {
      x: 50,
      y: currentY,
      size: 12,
      font: this.font,
      color: rgb(0.4, 0.4, 0.4)
    })

    currentY -= 50

    // Classification result
    const resultColor = classification.prediction === 'outlier' ? rgb(0.8, 0.2, 0.2) : rgb(0.2, 0.6, 0.2)
    
    page.drawText('Classification Result:', {
      x: 50,
      y: currentY,
      size: 16,
      font: this.boldFont,
      color: rgb(0, 0, 0)
    })

    currentY -= 30

    page.drawText(display.label, {
      x: 50,
      y: currentY,
      size: 24,
      font: this.boldFont,
      color: resultColor
    })

    page.drawText(`${display.confidenceText}`, {
      x: 50,
      y: currentY - 25,
      size: 12,
      font: this.font,
      color: rgb(0.4, 0.4, 0.4)
    })

    currentY -= 60

    // Interpretation
    page.drawText('Interpretation:', {
      x: 50,
      y: currentY,
      size: 14,
      font: this.boldFont,
      color: rgb(0, 0, 0)
    })

    currentY -= 25

    const interpretationLines = this.wrapText(display.interpretation, this.font, 12, width - 100)
    interpretationLines.forEach(line => {
      page.drawText(line, {
        x: 50,
        y: currentY,
        size: 12,
        font: this.font,
        color: rgb(0, 0, 0)
      })
      currentY -= 18
    })

    currentY -= 20

    // Reasoning
    page.drawText('Analysis Reasoning:', {
      x: 50,
      y: currentY,
      size: 14,
      font: this.boldFont,
      color: rgb(0, 0, 0)
    })

    currentY -= 25

    classification.reasoning.forEach(reason => {
      const lines = this.wrapText(reason, this.font, 11, width - 120)
      lines.forEach(line => {
        page.drawText(`• ${line}`, {
          x: 60,
          y: currentY,
          size: 11,
          font: this.font,
          color: rgb(0.2, 0.2, 0.2)
        })
        currentY -= 16
      })
      currentY -= 5
    })
  }

  private addDataPreviewPage(parsedData: ParsedData): void {
    const page = this.pdfDoc!.addPage(PageSizes.A4)
    const { width, height } = page.getSize()
    
    let currentY = height - 80

    // Page title
    page.drawText('Data Summary', {
      x: 50,
      y: currentY,
      size: 20,
      font: this.boldFont,
      color: rgb(0.2, 0.2, 0.6)
    })
    
    currentY -= 50

    // File info
    const fileInfo = [
      `File Name: ${parsedData.originalFile.name}`,
      `File Size: ${(parsedData.originalFile.size / 1024).toFixed(1)} KB`,
      `Rows: ${parsedData.rows.length}`,
      `Columns: ${parsedData.headers.length}`
    ]

    fileInfo.forEach(info => {
      page.drawText(info, {
        x: 50,
        y: currentY,
        size: 12,
        font: this.font,
        color: rgb(0, 0, 0)
      })
      currentY -= 20
    })

    currentY -= 20

    // Column types
    page.drawText('Column Types:', {
      x: 50,
      y: currentY,
      size: 14,
      font: this.boldFont,
      color: rgb(0, 0, 0)
    })

    currentY -= 25

    Object.entries(parsedData.inferredTypes).forEach(([header, type]) => {
      page.drawText(`${header}: ${type}`, {
        x: 60,
        y: currentY,
        size: 11,
        font: this.font,
        color: rgb(0.3, 0.3, 0.3)
      })
      currentY -= 16
    })

    // Data quality warnings
    if (parsedData.warnings.length > 0) {
      currentY -= 20

      page.drawText('Data Quality Warnings:', {
        x: 50,
        y: currentY,
        size: 14,
        font: this.boldFont,
        color: rgb(0.8, 0.4, 0)
      })

      currentY -= 25

      parsedData.warnings.forEach(warning => {
        const lines = this.wrapText(warning, this.font, 10, width - 100)
        lines.forEach(line => {
          page.drawText(`• ${line}`, {
            x: 60,
            y: currentY,
            size: 10,
            font: this.font,
            color: rgb(0.6, 0.3, 0)
          })
          currentY -= 14
        })
        currentY -= 5
      })
    }
  }

  private async addChartsPages(chartElements: HTMLElement[]): Promise<void> {
    for (const element of chartElements) {
      try {
        const canvas = await html2canvas(element, {
          backgroundColor: '#ffffff',
          scale: 2,
          useCORS: true
        })
        
        const page = this.pdfDoc!.addPage(PageSizes.A4)
        const { width, height } = page.getSize()
        
        const pngImageBytes = this.canvasToBytes(canvas)
        const pngImage = await this.pdfDoc!.embedPng(pngImageBytes)
        
        const imageWidth = Math.min(width - 100, pngImage.width * 0.5)
        const imageHeight = (pngImage.height * imageWidth) / pngImage.width
        
        const x = (width - imageWidth) / 2
        const y = height - 100 - imageHeight
        
        page.drawText('Visualization', {
          x: 50,
          y: height - 50,
          size: 16,
          font: this.boldFont,
          color: rgb(0.2, 0.2, 0.6)
        })
        
        page.drawImage(pngImage, {
          x,
          y,
          width: imageWidth,
          height: imageHeight
        })
      } catch (error) {
        console.error('Failed to capture chart:', error)
      }
    }
  }

  private wrapText(text: string, font: any, fontSize: number, maxWidth: number): string[] {
    const words = text.split(' ')
    const lines: string[] = []
    let currentLine = ''

    words.forEach(word => {
      const testLine = currentLine + (currentLine ? ' ' : '') + word
      const testWidth = font.widthOfTextAtSize(testLine, fontSize)
      
      if (testWidth <= maxWidth) {
        currentLine = testLine
      } else {
        if (currentLine) {
          lines.push(currentLine)
          currentLine = word
        } else {
          lines.push(word)
        }
      }
    })

    if (currentLine) {
      lines.push(currentLine)
    }

    return lines
  }

  private canvasToBytes(canvas: HTMLCanvasElement): Uint8Array {
    const dataUrl = canvas.toDataURL('image/png')
    const base64 = dataUrl.split(',')[1]
    const binaryString = atob(base64)
    const bytes = new Uint8Array(binaryString.length)
    
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i)
    }
    
    return bytes
  }
}

// Utility function to download PDF
export function downloadPDF(pdfBytes: Uint8Array, fileName: string): void {
  const blob = new Blob([pdfBytes], { type: 'application/pdf' })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  
  link.href = url
  link.download = fileName
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}